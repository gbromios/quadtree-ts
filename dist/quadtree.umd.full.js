/* https://github.com/timohausmann/quadtree-ts.git v2.0.0-beta.2 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("gl-matrix")):"function"==typeof define&&define.amd?define(["gl-matrix"],e):(t="undefined"!=typeof globalThis?globalThis:t||self).Quadtree=e(t.glMatrix)}(this,(function(t){"use strict";function e(){let t=this.x.toString(),e=this.y.toString();return t.length>5&&(t=t.slice(0,5)+"…"),e.length>5&&(e=e.slice(0,5)+"…"),`NodeGeometry([${t}, ${e}] ${this.width} × ${this.height})`}function i(){return this.position[0]}function s(){return this.position[1]}function n(t){this.position[0]=t}function r(t){this.position[1]=t}function o(){return this.size[0]}function h(){return this.size[1]}function c(t){this.size[0]=t}function l(t){this.size[1]=t}function a(e,i,s,n){return t.vec2.scaleAndAdd(null!=n?n:e,i,s,.5),e}function u(u,d){var f,b;const y=new ArrayBuffer(6*Float32Array.BYTES_PER_ELEMENT),x=new Float32Array(y,0,2),m=new Float32Array(y,8,2),v=new Float32Array(y,8,2);return void 0===d?(x[0]=null!==(f=u.x)&&void 0!==f?f:0,x[1]=null!==(b=u.y)&&void 0!==b?b:0,m[0]=u.width,m[1]=u.height):(t.vec2.copy(x,u),t.vec2.copy(m,d)),Object.create(null,{buffer:{value:y},position:{value:x,enumerable:!0},size:{value:m,enumerable:!0},x:{get:i,set:n,enumerable:!0},y:{get:s,set:r,enumerable:!0},width:{get:o,set:c,enumerable:!0},height:{get:h,set:l,enumerable:!0},center:{value:a.bind(null,v,x,m)},toString:{value:e,enumerable:!0}})}class d{constructor(t,e=0){var i,s,n;if(this._size=0,this.bounds=u(t),this.maxObjects=null!==(i=t.maxObjects)&&void 0!==i?i:10,this.maxObjects<1)throw new Error("maxObjects must be > 0");this.minObjects=null!==(s=t.minObjects)&&void 0!==s?s:Math.floor(this.maxObjects/2),this.maxLevels=null!==(n=t.maxLevels)&&void 0!==n?n:4,this.level=e,this.objects=[],this.nodes=null}*getIndex(t){if(this.nodes)for(const e of t.qtIndex(this.bounds))yield this.nodes[e]}split(){var t;if(this.nodes||!this.objects)throw new Error("already split!");this.nodes=function(t){const e=t.bounds.width/2,i=t.bounds.height/2,s=t.bounds.x,n=t.bounds.y,r=t.level+1,o={width:e,height:i,maxObjects:t.maxObjects,maxLevels:t.maxLevels};return Object.freeze([new d(Object.assign({x:s+e,y:n},o),r),new d(Object.assign({x:s,y:n},o),r),new d(Object.assign({x:s,y:n+i},o),r),new d(Object.assign({x:s+e,y:n+i},o),r)])}(this);for(const e of this.objects)for(const i of this.getIndex(e))i._size++,null===(t=i.objects)||void 0===t||t.push(e);this.objects=null}insert(t){if(this.nodes)for(const e of this.getIndex(t))e.insert(t);else{if(!this.objects)throw new Error("nowhere to store objects!");this.objects.push(t)>this.maxObjects&&this.level<this.maxLevels&&this.split()}this._size++}retrieve(t,e,i,s){if(null!=e||(e=[]),this.objects)i?e.push(...this.objects.filter(i)):e.push(...this.objects);else{if(!this.nodes)throw new Error("no nodes or objects!!");i&&!s||(i=this._makePredicate(i));for(const s of this.getIndex(t))s.retrieve(t,e,i,!1)}return e}_makePredicate(t){const e=new Set;return t?i=>!e.has(i)&&(e.add(i),t(i)):t=>!e.has(t)&&(e.add(t),!0)}clear(t=!1){t?(this.objects=[],this.nodes=null,this._size=0):(this.objects=[...this].filter((t=>t.qtStatic)),this.nodes=null,this.rebalance())}rebalance(){const t=[...this];this.clear(!0);for(const e of t)this.insert(e)}get size(){return this._size}remove(t,e){if(this.objects){const e=this.objects.indexOf(t);return-1!==e&&(this._size--,this.objects.splice(e,1),!0)}if(this.nodes){let i=!1;for(const e of this.getIndex(t))i=e.remove(t,!1)||i;return i&&(this._size--,(null!=e?e:this.size<=this.minObjects)&&this.consolidate()),i}return!1}removeMultiple(t,e){let i=!1;for(const e of t)i=this.remove(e)||i;return i&&(null!=e?e:this.size<=this.minObjects)&&this.consolidate(),i}consolidate(){if(!this.nodes)return!1;if(this.size<=this.maxObjects)return this.objects=[...this],this.nodes=null,!0;let t=!1;for(const e of this.nodes)t=e.consolidate()||t;return t}*values(t,e){if(this.objects)if(t)for(const e of this.objects)t(e)&&(yield e);else for(const t of this.objects)yield t;else if(this.nodes){t&&!e||(t=this._makePredicate(t));for(const e of this.nodes)for(const i of e.values(t,!1))yield i}}[Symbol.iterator](){return this.values(this._makePredicate())}}class f{constructor(e){this.center=t.vec2.fromValues(e.x,e.y),this.r=e.r,this.qtStatic=e.qtStatic,this.data=e.data}get x(){return this.center[0]}set x(t){this.center[0]=t}get y(){return this.center[1]}set y(t){this.center[1]=t}*qtIndex(e){const i=u(e.position,e.size);t.vec2.scale(i.size,i.size,.5),this.intersectRect(i)&&(yield 1),i.position[0]+=i.size[0],this.intersectRect(i)&&(yield 0),i.position[1]+=i.size[1],this.intersectRect(i)&&(yield 3),i.position[0]-=i.size[0],this.intersectRect(i)&&(yield 2)}static intersectRect(t,e,i,s,n,r,o){const h=t-Math.max(s,Math.min(t,r)),c=e-Math.max(n,Math.min(e,o));return h*h+c*c<i*i}intersectRect(t,e){return e||({position:t,size:e}=t),f.intersectRect(this.center[0],this.center[1],this.r,t[0],t[1],t[0]+e[0],t[1]+e[1])}}class b{constructor(t){var e;this.buffer=new ArrayBuffer(4*Float32Array.BYTES_PER_ELEMENT),this.a=new Float32Array(this.buffer,0,2),this.b=new Float32Array(this.buffer,8,2),this.a[0]=t.x1,this.a[1]=t.y1,this.b[0]=t.x2,this.b[1]=t.y2,this.qtStatic=null!==(e=t.qtStatic)&&void 0!==e&&e,null!=t.data&&(this.data=t.data)}toString(){return`Line([${this.a[0]}, ${this.a[1]}] → [${this.b[0]}, ${this.b[1]}])`}get x1(){return this.a[0]}set x1(t){this.a[0]=t}get y1(){return this.a[1]}set y1(t){this.a[1]=t}get x2(){return this.b[0]}set x2(t){this.b[0]=t}get y2(){return this.b[1]}set y2(t){this.b[1]=t}*qtIndex(e){const i=u(e.position,e.size);t.vec2.scale(i.size,i.size,.5),this.intersectRect(i)&&(yield 1),i.position[0]+=i.size[0],this.intersectRect(i)&&(yield 0),i.position[1]+=i.size[1],this.intersectRect(i)&&(yield 3),i.position[0]-=i.size[0],this.intersectRect(i)&&(yield 2)}intersectRect(t,e){return e||({position:t,size:e}=t),b.intersectRect(this.a[0],this.a[1],this.b[0],this.b[1],t[0],t[1],t[0]+e[0],t[1]+e[1])}*[Symbol.iterator](){yield this.a[0],yield this.a[1],yield this.b[0],yield this.b[1]}static intersectRect(t,e,i,s,n,r,o,h){if(t<=n&&i<=n||e<=r&&s<=r||t>=o&&i>=o||e>=h&&s>=h)return!1;if(t>=n&&t<=o&&e>=r&&e<=h||i>=n&&i<=o&&s>=r&&s<=h)return!0;const c=(s-e)/(i-t);let l=c*(n-t)+e;if(l>r&&l<h)return!0;if(l=c*(o-t)+e,l>r&&l<h)return!0;let a=(r-e)/c+t;return a>n&&a<o||(a=(h-e)/c+t,a>n&&a<o)}}return Object.assign(d,{Rectangle:class{constructor(t){var e,i,s;this.buffer=new ArrayBuffer(4*Float32Array.BYTES_PER_ELEMENT),this.position=new Float32Array(this.buffer,0,2),this.size=new Float32Array(this.buffer,8,2),this.position[0]=null!==(e=t.x)&&void 0!==e?e:0,this.position[1]=null!==(i=t.y)&&void 0!==i?i:0,this.size[0]=t.width,this.size[1]=t.height,this.qtStatic=null!==(s=t.qtStatic)&&void 0!==s&&s,null!=t.data&&(this.data=t.data)}get x(){return this.position[0]}set x(t){this.position[0]=t}get y(){return this.position[1]}set y(t){this.position[1]=t}get width(){return this.size[0]}set width(t){this.size[0]=t}get height(){return this.size[1]}set height(t){this.size[1]=t}*qtIndex(e){const i=e.center(),s=this.position[0]<i[0],n=this.position[1]<i[1],r=t.vec2.add(t.vec2.create(),this.size,this.position),o=r[0]>i[0],h=r[1]>i[1];n&&o&&(yield 0),s&&n&&(yield 1),s&&h&&(yield 2),o&&h&&(yield 3)}},Circle:f,Line:b})}));
