/* https://github.com/timohausmann/quadtree-ts.git v2.0.0-beta.2 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("gl-matrix")):"function"==typeof define&&define.amd?define(["gl-matrix"],e):(t="undefined"!=typeof globalThis?globalThis:t||self).Quadtree=e(t.glMatrix)}(this,(function(t){"use strict";function e(){let t=this.x.toString(),e=this.y.toString();return t.length>5&&(t=t.slice(0,5)+"…"),e.length>5&&(e=e.slice(0,5)+"…"),`NodeGeometry([${t}, ${e}] ${this.width} × ${this.height})`}function s(){return this.position[0]}function i(){return this.position[1]}function n(t){this.position[0]=t}function o(t){this.position[1]=t}function r(){return this.size[0]}function h(){return this.size[1]}function l(t){this.size[0]=t}function c(t){this.size[1]=t}function a(e,s,i,n){return t.vec2.scaleAndAdd(null!=n?n:e,s,i,.5),e}class u{constructor(u,d=0){var f,b,j;if(this._size=0,this.bounds=function(u,d){var f,b;const j=new ArrayBuffer(6*Float32Array.BYTES_PER_ELEMENT),m=new Float32Array(j,0,2),v=new Float32Array(j,8,2),g=new Float32Array(j,8,2);return void 0===d?(m[0]=null!==(f=u.x)&&void 0!==f?f:0,m[1]=null!==(b=u.y)&&void 0!==b?b:0,v[0]=u.width,v[1]=u.height):(t.vec2.copy(m,u),t.vec2.copy(v,d)),Object.create(null,{buffer:{value:j},position:{value:m,enumerable:!0},size:{value:v,enumerable:!0},x:{get:s,set:n,enumerable:!0},y:{get:i,set:o,enumerable:!0},width:{get:r,set:l,enumerable:!0},height:{get:h,set:c,enumerable:!0},center:{value:a.bind(null,g,m,v)},toString:{value:e,enumerable:!0}})}(u),this.maxObjects=null!==(f=u.maxObjects)&&void 0!==f?f:10,this.maxObjects<1)throw new Error("maxObjects must be > 0");this.minObjects=null!==(b=u.minObjects)&&void 0!==b?b:Math.floor(this.maxObjects/2),this.maxLevels=null!==(j=u.maxLevels)&&void 0!==j?j:4,this.level=d,this.objects=[],this.nodes=null}*getIndex(t){if(this.nodes)for(const e of t.qtIndex(this.bounds))yield this.nodes[e]}split(){var t;if(this.nodes||!this.objects)throw new Error("already split!");this.nodes=function(t){const e=t.bounds.width/2,s=t.bounds.height/2,i=t.bounds.x,n=t.bounds.y,o=t.level+1,r={width:e,height:s,maxObjects:t.maxObjects,maxLevels:t.maxLevels};return Object.freeze([new u(Object.assign({x:i+e,y:n},r),o),new u(Object.assign({x:i,y:n},r),o),new u(Object.assign({x:i,y:n+s},r),o),new u(Object.assign({x:i+e,y:n+s},r),o)])}(this);for(const e of this.objects)for(const s of this.getIndex(e))s._size++,null===(t=s.objects)||void 0===t||t.push(e);this.objects=null}insert(t){if(this.nodes)for(const e of this.getIndex(t))e.insert(t);else{if(!this.objects)throw new Error("nowhere to store objects!");this.objects.push(t)>this.maxObjects&&this.level<this.maxLevels&&this.split()}this._size++}retrieve(t,e,s,i){if(null!=e||(e=[]),this.objects)s?e.push(...this.objects.filter(s)):e.push(...this.objects);else{if(!this.nodes)throw new Error("no nodes or objects!!");s&&!i||(s=this._makePredicate(s));for(const i of this.getIndex(t))i.retrieve(t,e,s,!1)}return e}_makePredicate(t){const e=new Set;return t?s=>!e.has(s)&&(e.add(s),t(s)):t=>!e.has(t)&&(e.add(t),!0)}clear(t=!1){t?(this.objects=[],this.nodes=null,this._size=0):(this.objects=[...this].filter((t=>t.qtStatic)),this.nodes=null,this.rebalance())}rebalance(){const t=[...this];this.clear(!0);for(const e of t)this.insert(e)}get size(){return this._size}remove(t,e){if(this.objects){const e=this.objects.indexOf(t);return-1!==e&&(this._size--,this.objects.splice(e,1),!0)}if(this.nodes){let s=!1;for(const e of this.getIndex(t))s=e.remove(t,!1)||s;return s&&(this._size--,(null!=e?e:this.size<=this.minObjects)&&this.consolidate()),s}return!1}removeMultiple(t,e){let s=!1;for(const e of t)s=this.remove(e)||s;return s&&(null!=e?e:this.size<=this.minObjects)&&this.consolidate(),s}consolidate(){if(!this.nodes)return!1;if(this.size<=this.maxObjects)return this.objects=[...this],this.nodes=null,!0;let t=!1;for(const e of this.nodes)t=e.consolidate()||t;return t}*values(t,e){if(this.objects)if(t)for(const e of this.objects)t(e)&&(yield e);else for(const t of this.objects)yield t;else if(this.nodes){t&&!e||(t=this._makePredicate(t));for(const e of this.nodes)for(const s of e.values(t,!1))yield s}}[Symbol.iterator](){return this.values(this._makePredicate())}}return Object.assign(u,{Rectangle:class{constructor(t){var e,s,i;this.buffer=new ArrayBuffer(4*Float32Array.BYTES_PER_ELEMENT),this.position=new Float32Array(this.buffer,0,2),this.size=new Float32Array(this.buffer,8,2),this.position[0]=null!==(e=t.x)&&void 0!==e?e:0,this.position[1]=null!==(s=t.y)&&void 0!==s?s:0,this.size[0]=t.width,this.size[1]=t.height,this.qtStatic=null!==(i=t.qtStatic)&&void 0!==i&&i,null!=t.data&&(this.data=t.data)}get x(){return this.position[0]}set x(t){this.position[0]=t}get y(){return this.position[1]}set y(t){this.position[1]=t}get width(){return this.size[0]}set width(t){this.size[0]=t}get height(){return this.size[1]}set height(t){this.size[1]=t}*qtIndex(e){const s=e.center(),i=this.position[0]<s[0],n=this.position[1]<s[1],o=t.vec2.add(t.vec2.create(),this.size,this.position),r=o[0]>s[0],h=o[1]>s[1];n&&r&&(yield 0),i&&n&&(yield 1),i&&h&&(yield 2),r&&h&&(yield 3)}}})}));
